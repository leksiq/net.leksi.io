<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="ru"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>BranchReader.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCoverage analysis of project &quot;BranchReader&quot; (powered by JaCoCo from EclEmma)</a> &gt; <a href="index.source.html" class="el_package">net.leksi.io</a> &gt; <span class="el_source">BranchReader.java</span></div><h1>BranchReader.java</h1><pre class="source lang-java linenums">/*
 * BranchReader
 * 
 * v.0.0.1
 * 
 * 23-08-2019
 *
 * The MIT License
 *
 * Copyright 2019 Alexey Zakharov &lt;leksi@leksi.net&gt;.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
package net.leksi.io;

import java.io.IOException;
import java.io.Reader;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * The class {@code BranchReader} is for different consumers to 
 * independently read the same {@code Reader}.
 *
 * @author Alexey Zakharov &amp;lt;leksi@leksi.net&amp;gt;
 * @since JDK1.8
 */
<span class="fc" id="L46">abstract public class BranchReader extends Reader {</span>
    
    /**
     * Returns an array of {@code count} new branches {@code BranchReader}
     * which can be read from the current position of the parent's 
     * {@code BranchReader}.
     * 
     * @param count a number of new branches
     * @return an array of new branches
     * @throws IOException if it is closed
     */
    abstract public BranchReader[] branch(final int count) throws IOException;
    
    /**
     * Returns a boolean value meaning if the 
     * {@code BranchReader} is closed.
     * 
     * @return   a boolean value meaning if the 
     *           {@code BranchReader} is closed
     */
    abstract public boolean isClosed();
    
    /**
     * A factory method for creation of an {@code BranchReader} object of 
     * the concrete implementation based on the openned underlying
     * {@code Reader}. The  reading is possible from the current position of the 
     * {@code source}.
     * 
     * @param source the preliminary openned {@code Reader}
     * @return root {@code BranchReader} object
     */
    static public BranchReader create(final Reader source) {
<span class="fc" id="L78">        return new Root(source).root();</span>
    }
    
    /**
     * The class {@code ChunkHolder} is an auxiliary class to support a singly 
     * linked list of data pieces read from the underlying {@code Reader}. 
     * &lt;p&gt;
     * In order to use memory sparingly we point the end chunk which is a point 
     * of grouth and every branch points its currently read chunk. Thus, chunks 
     * read by all branches are objects for the GC.
     */
    private static class ChunkHolder {
        /**
         * The actual chunk length.
         */
<span class="fc" id="L93">        private int length = 0;</span>
        /**
         * The {@code char} array to contain the data chunk.
         */
<span class="fc" id="L97">        private char buffer[] = null;</span>
        /**
         * The pointer to the next chunk.
         */
<span class="fc" id="L101">        private ChunkHolder next = null;</span>
<span class="fc" id="L102">        private long offset = 0;</span>

        /**
         * Creates a chunk of predefined size.
         * @param chunkSize size of memory in {@code char}s to allocate for the chunk.
         */
<span class="fc" id="L108">        private ChunkHolder(final int chunkSize) {</span>
<span class="fc" id="L109">            buffer = new char[chunkSize];</span>
<span class="fc" id="L110">        }</span>
    }

    /**
     * The class {@code Root} is an infrastructure holder for the &lt;i&gt;tree&lt;/i&gt; of 
     * {@code BranchReader} objects.
     */
    private static class Root {
        /**
         * The underlying {@code Reader}.
         */
<span class="fc" id="L121">        private Reader source = null;</span>
        /**
         * The flag indicating that the underlying {@code Reader} is fully read.
         */
<span class="fc" id="L125">        private AtomicBoolean isSourceEnded = new AtomicBoolean(false);</span>
        /**
         * The list of all branches of the tree.
         */
<span class="fc" id="L129">        private final List&lt;Branch&gt; branches = Collections.synchronizedList(</span>
                new ArrayList&lt;&gt;());
        /**
         * The last chunk at the singly linked list of data pieces read from the 
         * underlying {@code Reader}.
         */
<span class="fc" id="L135">        private ChunkHolder endChunk = new ChunkHolder(0);</span>
        /**
         * The class {@code Branch} is a concrete implementation of the abstract
         * {@code BranchReader}.
         */
        
        private class Branch extends BranchReader {
            /**
             * The current offset relative to the issue of the 
             * underlying {@code Reader}.
             */
<span class="fc" id="L146">            private long position = 0;</span>
            /**
             * The chunk currently being read.
             */
<span class="fc" id="L150">            private ChunkHolder chunk = null;</span>

            /**
             * Creates a branch with a parent if it is given
             * 
             * @param parent    a parent branch of the new branch or 
             *                  {@code null} in the case of root
             */
<span class="fc" id="L158">            private Branch(final Branch parent) {</span>
<span class="fc bfc" id="L159" title="All 2 branches covered.">                if (parent != null) { </span>
                    /**
                     * if the parent is given, just clone it
                     */
<span class="fc" id="L163">                    position = parent.position;</span>
<span class="fc" id="L164">                    chunk = parent.chunk;</span>
                }
<span class="fc" id="L166">            }</span>

            @Override
            public BranchReader[] branch(final int count) throws IOException {
                BranchReader[] res;
                
<span class="fc bfc" id="L172" title="All 2 branches covered.">                if (isClosed()) {</span>
<span class="fc" id="L173">                    throw new IOException(&quot;Cannot branch closed reader&quot;);</span>
                }
<span class="fc" id="L175">                res = new BranchReader[count];</span>
<span class="fc bfc" id="L176" title="All 2 branches covered.">                for (int i = 0; i &lt; count; i++) {</span>
<span class="fc" id="L177">                    res[i] = new Branch(this);</span>
<span class="fc" id="L178">                    branches.add((Branch) res[i]);</span>
                }
<span class="fc" id="L180">                return res;</span>
            }

            @Override
            public boolean isClosed() {
<span class="fc bfc" id="L185" title="All 2 branches covered.">                return !branches.contains(this);</span>
            }

            @Override
            public int read(final char[] cbuf, 
                    final int off, final int len) throws IOException {
<span class="fc" id="L191">                int res = len;              // returned result</span>
<span class="fc" id="L192">                int readCount = 0;          // cumulative count of chars copied </span>
                                            // from (probably) several chunks
                
<span class="fc bfc" id="L195" title="All 2 branches covered.">                if (isClosed()) {</span>
<span class="fc" id="L196">                    throw new IOException(&quot;Cannot read closed reader&quot;);</span>
                }

<span class="fc bfc" id="L199" title="All 2 branches covered.">                if(!isSourceEnded.get()) {</span>
<span class="fc bfc" id="L200" title="All 2 branches covered.">                    if (position + len &gt; getDataLength()) {</span>
                        /**
                         * Should read from the underlying {@code Reader}.
                         */
<span class="fc" id="L204">                        readFromSource(position + len);</span>
                    }
                }
<span class="fc bfc" id="L207" title="All 2 branches covered.">                if (isSourceEnded.get()) {</span>
                    /**
                     * Correct requested amount if it is less than the 
                     * rest data amount
                     */
<span class="fc" id="L212">                    res = (int)Math.min((long)len, endChunk.offset </span>
<span class="fc" id="L213">                            + endChunk.length - position</span>
                            );
                }
<span class="fc bfc" id="L216" title="All 2 branches covered.">                while (readCount &lt; res) {</span>
                    int from;
                    int n;
                    
<span class="fc bfc" id="L220" title="All 2 branches covered.">                    if (position &gt;= chunk.offset + chunk.length) {</span>
<span class="fc" id="L221">                        chunk = chunk.next;</span>
                    }
<span class="fc" id="L223">                    from = (int)(position - chunk.offset);</span>
<span class="fc" id="L224">                    n = Math.min(chunk.length - from, res - readCount);</span>
<span class="fc" id="L225">                    System.arraycopy(chunk.buffer, from, cbuf, off + readCount, n);</span>
<span class="fc" id="L226">                    position += n;</span>
<span class="fc" id="L227">                    readCount += n;</span>
<span class="fc" id="L228">                }</span>
<span class="fc" id="L229">                return res;</span>
            }

            @Override
            public void close() throws IOException {
<span class="fc" id="L234">                closeBranch(this);</span>
<span class="fc" id="L235">            }</span>
        }
        
        /**
         * Returns the length of the data currently read from source.
         * 
         * @return the length of the data currently read from source
         */
        private synchronized long getDataLength() {
<span class="fc" id="L244">            return endChunk.offset + endChunk.length;</span>
        }
        
        /**
         * Reads lacking data from underlying {@code Reader} in case of expected
         * position plus requested length is greate than actually read data
         * length
         * 
         * @param postionAfterRead position plus requested length
         * @throws IOException in case of I/O error while reading from the 
         * underlying {@code Reader}.
         */
        private synchronized void readFromSource(final long postionAfterRead) 
                throws IOException {
<span class="fc" id="L258">            long dataLength = endChunk.offset + endChunk.length;</span>
<span class="fc bfc" id="L259" title="All 2 branches covered.">            if (postionAfterRead &gt; dataLength) {</span>
                /**
                 * Should read from the underlying {@code Reader}.
                 */
<span class="fc" id="L263">                int leftReadCount = (int) (postionAfterRead - dataLength);</span>
                /**
                 * Allocate new chunk and add it to list
                 */
<span class="fc" id="L267">                endChunk.next = new ChunkHolder(leftReadCount);</span>
<span class="fc" id="L268">                endChunk.next.offset = dataLength;</span>
<span class="fc" id="L269">                endChunk = endChunk.next;</span>

<span class="fc bfc" id="L271" title="All 2 branches covered.">                while (leftReadCount &gt; 0) {</span>
<span class="fc" id="L272">                    int n = source.read(endChunk.buffer,</span>
<span class="fc" id="L273">                            endChunk.length,</span>
<span class="fc" id="L274">                            Math.min(leftReadCount,</span>
<span class="fc" id="L275">                                    endChunk.buffer.length</span>
<span class="fc" id="L276">                                    - endChunk.length));</span>
<span class="fc bfc" id="L277" title="All 2 branches covered.">                    if (n &lt;= 0) {</span>
<span class="fc" id="L278">                        isSourceEnded.set(true);</span>
<span class="fc" id="L279">                        break;</span>
                    }
<span class="fc" id="L281">                    endChunk.length += n;</span>
<span class="fc" id="L282">                    leftReadCount -= n;</span>
<span class="fc" id="L283">                }</span>
            }
<span class="fc" id="L285">        }</span>
        
        /**
         * Closes branch and the underlying {@code Reader} if all branches are 
         * closed.
         * 
         * @param branch the branch to close
         * @throws IOException in case of I/O error while closing the underlying 
         * {@code Reader}.
         */
        private synchronized void closeBranch(final Branch branch) throws IOException {
<span class="fc" id="L296">            branches.remove(branch);</span>
<span class="fc bfc" id="L297" title="All 4 branches covered.">            if (branches.isEmpty() &amp;&amp; source != null) {</span>
<span class="fc" id="L298">                source.close();</span>
<span class="fc" id="L299">                source = null;</span>
            }
<span class="fc" id="L301">        }</span>

        /**
         * Creates new {@code Root} object with an underlying {@code Reader}.
         * 
         * @param source the underlying {@code Reader}.
         */
<span class="fc" id="L308">        private Root(final Reader source) {</span>
<span class="fc" id="L309">            this.source = source;</span>
<span class="fc" id="L310">        }</span>

        /**
         * Creates and returns the root branch
         * 
         * @return the root branch
         */
        private Branch root() {
<span class="fc" id="L318">            Branch root = new Branch(null);</span>
<span class="fc" id="L319">            root.chunk = endChunk;</span>
<span class="fc" id="L320">            branches.add(root);</span>
<span class="fc" id="L321">            return root;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>